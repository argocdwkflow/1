# .gitlab-ci.yml
# Build bp2iutils pour EL6/7/8/9/10
# Publication vers :
#   - Artifacts GitLab
#   - Artifactory (RPM repo)
#   - NFS partagé (via runner avec accès NFS)

stages:
  - build
  - publish
  - repo

# -------------------------
# Variables globales
# -------------------------
variables:
  RPM_NAME: "bp2iutils"

  # Arbre rpmbuild dans les images builder
  RPM_TOPDIR: "/root/rpmbuild"

  # Racine du dépôt NFS vue depuis le job (montée par le runner NFS)
  NFS_ROOT: "/rpmrepo"

  # Artifactory (à adapter à ton infra)
  ARTIFACTORY_URL: "https://artifactory.example.com/artifactory"
  ARTIFACTORY_REPO: "rpm-local"              # nom du repo RPM
  ARTIFACTORY_BASE_PATH: "bp2iutils"         # sous-répertoire dans le repo

  # Variables secrètes à définir dans GitLab CI :
  #   ARTIFACTORY_USER
  #   ARTIFACTORY_PASSWORD ou ARTIFACTORY_API_KEY

# -------------------------
# Template BUILD
# -------------------------
.build_rpm_template: &build_rpm_template
  stage: build
  script:
    # 1) S'assurer que l'arbre rpmbuild existe
    - mkdir -p "$RPM_TOPDIR"/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
    - echo "%_topdir $RPM_TOPDIR" > /root/.rpmmacros

    # 2) Copier SOURCES et SPEC depuis le repo Git
    - cp -r "$CI_PROJECT_DIR"/SOURCES/* "$RPM_TOPDIR"/SOURCES/
    - cp "$CI_PROJECT_DIR"/SPECS/"$RPM_NAME".spec "$RPM_TOPDIR"/SPECS/

    # 3) Construire le RPM
    - cd "$RPM_TOPDIR"
    - rpmbuild -ba "SPECS/$RPM_NAME.spec"

    # 4) Récupérer les artefacts locaux
    - mkdir -p "$CI_PROJECT_DIR"/dist/"$TARGET"
    - cp "$RPM_TOPDIR"/RPMS/*/*.rpm "$CI_PROJECT_DIR"/dist/"$TARGET"/
    - cp "$RPM_TOPDIR"/SRPMS/*.src.rpm "$CI_PROJECT_DIR"/dist/"$TARGET"/ || true

  artifacts:
    paths:
      - dist/
    expire_in: 1 week
  tags:
    - docker

# -------------------------
# Jobs de BUILD (EL6 → EL10)
# -------------------------

build:el6:
  <<: *build_rpm_template
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el6
  variables:
    TARGET: "el6"

build:el7:
  <<: *build_rpm_template
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el7
  variables:
    TARGET: "el7"

build:el8:
  <<: *build_rpm_template
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el8
  variables:
    TARGET: "el8"

build:el9:
  <<: *build_rpm_template
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el9
  variables:
    TARGET: "el9"

build:el10:
  <<: *build_rpm_template
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el10
  variables:
    TARGET: "el10"
  # Tu actives ce job quand ton builder EL10 est prêt
  # rules:
  #   - when: manual

# -------------------------
# PUBLISH vers ARTIFACTORY
# -------------------------
# → Job unique qui récupère les artefacts dist/ de tous les builds
#   et push tous les .rpm dans Artifactory.

publish:artifactory:
  stage: publish
  image: registry.access.redhat.com/ubi8/ubi:latest
  needs:
    - build:el6
    - build:el7
    - build:el8
    - build:el9
    - build:el10
  script:
    - microdnf install -y findutils curl && microdnf clean all

    - echo "Upload des RPM vers Artifactory…"

    # Boucle sur tous les RPM générés
    - |
      for rpm in $(find dist -type f -name "*.rpm"); do
        echo "→ Upload $rpm"
        # Détermination de la "branche" EL à partir du chemin (dist/el7/...)
        TARGET_DIR=$(echo "$rpm" | awk -F'/' '{print $2}')  # ex: el7
        FILE_NAME=$(basename "$rpm")

        # Exemple d'URL finale :
        #  $ARTIFACTORY_URL/$ARTIFACTORY_REPO/$ARTIFACTORY_BASE_PATH/el7/$FILE_NAME
        UPLOAD_URL="$ARTIFACTORY_URL/$ARTIFACTORY_REPO/$ARTIFACTORY_BASE_PATH/$TARGET_DIR/$FILE_NAME"

        # Utilisation d'un token ou user/password
        # 1) Via API KEY :
        # curl -H "X-JFrog-Art-Api: $ARTIFACTORY_API_KEY" -T "$rpm" "$UPLOAD_URL"
        #
        # 2) Via user/password :
        curl -u "$ARTIFACTORY_USER:$ARTIFACTORY_PASSWORD" -T "$rpm" "$UPLOAD_URL"
      done
  tags:
    - docker
  artifacts:
    when: on_failure
    paths:
      - dist/
    expire_in: 1 week

# -------------------------
# PUBLISH vers NFS
# -------------------------
# → Job qui tourne uniquement sur un runner ayant accès NFS
#   /srv/rpmrepo (hôte) → /rpmrepo (dans le container via volumes)
#   tags: nfs-runner  (par ex.)

publish:nfs:
  stage: publish
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el8   # image avec rsync + createrepo_c
  needs:
    - build:el6
    - build:el7
    - build:el8
    - build:el9
    - build:el10
  script:
    - echo "Publication vers NFS dans $NFS_ROOT…"

    # Copier les RPM sur NFS
    - for v in el6 el7 el8 el9 el10; do
        if [ -d "dist/$v" ]; then
          echo "→ Sync dist/$v → $NFS_ROOT/$v" ;
          mkdir -p "$NFS_ROOT/$v" ;
          rsync -av "dist/$v/" "$NFS_ROOT/$v/" ;
        else
          echo "dist/$v non présent, skip" ;
        fi ;
      done

    # Mise à jour des métadonnées createrepo_c sur chaque répertoire ELx
    - for v in el6 el7 el8 el9 el10; do
        if [ -d "$NFS_ROOT/$v" ]; then
          echo "→ createrepo_c --update $NFS_ROOT/$v" ;
          createrepo_c --update "$NFS_ROOT/$v" ;
        fi ;
      done
  tags:
    - nfs-runner
  when: on_success