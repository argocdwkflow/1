Parfait, on passe à la version optimisée : les outils (rpm-build, createrepo, etc.) sont déjà dans les images Docker, donc le pipeline est plus rapide et plus propre.


---

1. Exemples d’images “builder” à construire UNE FOIS

Tu construis une image par version (et tu les pousses dans ton registry GitLab).

Dockerfile.builder-el7

FROM registry.access.redhat.com/ubi7/ubi:latest

RUN yum clean all && \
    yum install -y \
      rpm-build rpm-sign make gcc git tar gzip which \
      createrepo_c \
      shadow-utils && \
    yum clean all

# arbre rpmbuild pour root
RUN mkdir -p /root/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS} && \
    echo '%_topdir /root/rpmbuild' > /root/.rpmmacros

WORKDIR /root

Dockerfile.builder-el8

FROM registry.access.redhat.com/ubi8/ubi:latest

RUN microdnf install -y \
      rpm-build rpm-sign make gcc git tar gzip which \
      createrepo_c \
      shadow-utils && \
    microdnf clean all

RUN mkdir -p /root/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS} && \
    echo '%_topdir /root/rpmbuild' > /root/.rpmmacros

WORKDIR /root

Dockerfile.builder-el9

FROM registry.access.redhat.com/ubi9/ubi:latest

RUN microdnf install -y \
      rpm-build rpm-sign make gcc git tar gzip which \
      createrepo_c \
      shadow-utils && \
    microdnf clean all

RUN mkdir -p /root/rpmbuild/{BUILD,RPMS,SOURCES,SPECS,SRPMS} && \
    echo '%_topdir /root/rpmbuild' > /root/.rpmmacros

WORKDIR /root

Idem pour EL6 (image interne) et EL10 (quand UBI10 existera).

Build & push (exemple EL8) :

docker build -f Dockerfile.builder-el8 -t registry.gitlab.com/mon-groupe/rpmbuilder:el8 .
docker push registry.gitlab.com/mon-groupe/rpmbuilder:el8


---

2. .gitlab-ci.yml optimisé (complet)

# .gitlab-ci.yml optimisé : les images contiennent déjà rpm-build/createrepo
# et un /root/rpmbuild prêt à l'emploi.
#
# Prérequis côté runner :
#   - NFS monté sur l'hôte, ex : /srv/rpmrepo
#   - config.toml du runner docker :
#       volumes = ["/srv/rpmrepo:/rpmrepo"]

stages:
  - build
  - repo

variables:
  RPM_NAME: "bp2iutils"
  NFS_ROOT: "/rpmrepo"
  RPM_TOPDIR: "/root/rpmbuild"

# -------------------------------------------------------------------
# Template d’étapes de build (utilisé par tous les jobs build)
# -------------------------------------------------------------------
.build_rpm_template: &build_rpm_template
  stage: build
  script:
    # 1) Préparer l'arbre rpmbuild (normalement déjà créé dans l'image,
    #    mais on s'assure que rien ne manque)
    - mkdir -p "$RPM_TOPDIR"/{BUILD,RPMS,SOURCES,SPECS,SRPMS}
    - echo "%_topdir $RPM_TOPDIR" > /root/.rpmmacros

    # 2) Copier les sources et le .spec depuis le repo Git
    - cp -r "$CI_PROJECT_DIR"/SOURCES/* "$RPM_TOPDIR"/SOURCES/
    - cp "$CI_PROJECT_DIR"/SPECS/"$RPM_NAME".spec "$RPM_TOPDIR"/SPECS/

    # 3) Lancer la construction
    - cd "$RPM_TOPDIR"
    - rpmbuild -ba "SPECS/$RPM_NAME".spec

    # 4) Récupérer les artefacts localement dans le job
    - mkdir -p "$CI_PROJECT_DIR"/dist/"$TARGET"
    - cp "$RPM_TOPDIR"/RPMS/*/*.rpm "$CI_PROJECT_DIR"/dist/"$TARGET"/
    - cp "$RPM_TOPDIR"/SRPMS/*.src.rpm "$CI_PROJECT_DIR"/dist/"$TARGET"/ || true

    # 5) Publier sur le NFS
    - mkdir -p "$NFS_ROOT/$TARGET"
    - rsync -av "$CI_PROJECT_DIR"/dist/"$TARGET"/ "$NFS_ROOT/$TARGET/"

    # 6) (optionnel) Signature des RPM si tu injectes une clé GPG
    # - if [ -n "$GPG_PRIVATE_KEY" ]; then
    #     echo "$GPG_PRIVATE_KEY" | gpg --batch --import ;
    #     find "$NFS_ROOT/$TARGET" -name '*.rpm' -print0 |
    #       xargs -0 -n1 rpmsign --addsign ;
    #   fi

  artifacts:
    paths:
      - dist/
    expire_in: 1 week
  tags:
    - docker

# -------------------------------------------------------------------
# Jobs de build pour chaque version
# -------------------------------------------------------------------

build:el6:
  <<: *build_rpm_template
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el6
  variables:
    TARGET: "el6"

build:el7:
  <<: *build_rpm_template
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el7
  variables:
    TARGET: "el7"

build:el8:
  <<: *build_rpm_template
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el8
  variables:
    TARGET: "el8"

build:el9:
  <<: *build_rpm_template
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el9
  variables:
    TARGET: "el9"

build:el10:
  <<: *build_rpm_template
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el10
  variables:
    TARGET: "el10"
  # active quand ton image el10 est prête
  # rules:
  #   - when: manual

# -------------------------------------------------------------------
# Mise à jour des métadonnées createrepo sur le NFS
# -------------------------------------------------------------------

update:nfs_repo_metadata:
  stage: repo
  # on peut réutiliser une image builder (el8 par ex) qui contient déjà createrepo_c
  image: registry.gitlab.com/mon-groupe/rpmbuilder:el8
  needs:
    - build:el6
    - build:el7
    - build:el8
    - build:el9
    - build:el10
  script:
    # pour chaque version, si le dossier existe ⇒ createrepo_c --update
    - for v in el6 el7 el8 el9 el10; do
        if [ -d "$NFS_ROOT/$v" ]; then
          echo "Mise à jour du dépôt NFS pour $v dans $NFS_ROOT/$v" ;
          createrepo_c --update "$NFS_ROOT/$v" ;
        else
          echo "Dépôt $v absent, skip." ;
        fi ;
      done
  tags:
    - docker
  when: on_success


---

Avec ça :

Tu as 5 jobs de build parallèles (el6→el10) qui utilisent des images pré-équipées.

Chaque job balance ses RPM vers /rpmrepo/elX.

Un job final régénère les métadonnées yum/dnf sur le NFS.


Si tu veux, on peut faire ensuite la version “secure” (jobs séparés pour la signature avec Sigul / HSM, variables protégées GitLab, etc.).